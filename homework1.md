<p align=center><b>HOMEWORK 1</b></p>
Submitted by <br>

|First Name|Last Name|Student ID|
|----------| --------|----------|
|AVINASH RATNAVEL MAHARAJ |       RATNAVEL      |                 |
|CHIRAG                   |       KAMAT         |                 |
|SHAM PRASAD              |       PS            |                 |
|PRATHIMA                 |       S             |                 |
<h3>ANSWER 1  -  ESSENTIAL DIFFICULTIES</h3>
<p align="justify">&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspAccording to Brooks, essential difficulties are difficulties that occur because of inherent or intrinsic nature of the software.
Brooks states that 
</p>
>“The essence of a software entity is a construct of interlocking concepts: data sets, relationships among data items, algorithms, and invocations of functions. This essence is abstract in that such a conceptual construct is the same under many different representations. It is nonetheless highly precise and richly detailed.” 

<p align="justify">
(Definition from No Silver bullet article).  According to brooks 80% of difficulties in software systems arise due to Essential 
difficulties. From the article “No Silver Bullet” we can understand that software systems are inherently complex and have lot of 
requirements and lot of constraints. So these inherent behaviours of the software systems produce many difficulties for making and
maintaining software. Let us consider an example of a Health Care System. The software team would have developed the software and would
have given the software to the client for testing. After seeing that, client may request lot of changes to the requirement. This is one of the main essential difficulties. As stated in lecture customers will not know when to request for changes. If the changes stated by
the customers are more, then it is difficult for the software team to redesign the software. Another example can be, software designed
for one state may not be used in other state because the rules and environment change. We should consider all this inherent difficulties in mind before developing software.</p>

<h3>ANSWER 2  -  ACCIDENTAL DIFFICULTIES</h3>
<p>According to Brooks “Accidental Difficulties are those difficulties that today attend its production but are not inherent”.
According to him these difficulties account for only smaller part may be 20% of the difficulties. Some people understood this definition in a different way. Some people thought that accidental difficulties are difficulties that occur by chance. But actually brook meant accidental difficulties as that,“the use technique A for benefit B unfortunately introduced problem C into the process of software development” (According to the lecture).We can understand that some new tools or techniques that were produced to solve some problem actually introduce some other new problem. But these problems account only for 20%. He also says that a single technique could not increase the order of magnitude. It could be achieved only by combining multiple techniques and industry wide enforcement and discipline.Let us consider an example of introducing a new framework for development. The new framework would actually have advantages and can be faster but unfortunately the new framework itself can have some problems introduced into our system. May the new framework will not support windows XP but we would have used this for long time. </p>

<h3>ANSWER 3 - TYPES OF ESSENTIAL DIFFICULTIES</h3>
<p>
</p>


- **Complexity** :
Nowadays the software systems became more complex because many people started using it and also these systems became more powerful. Very big software systems actually have lot of states and became more complex. In software engineering abstraction is very difficult because every software will have its own modules. So each time we develop a software we must develop the modules according to that product’s requirements. For example a banking application is very much different from a health care application. So we cannot create abstractions. This may cause some problem such as product flaws, delays etc. </p>

- **Conformity** :
Anything may happen in a company or during software development. For example let us consider a company that produces multiple softwares to its clients. The CEO of the company may change the rules of the company, which may affect our development process. Integrating new software with the existing old system (legacy system) becomes difficult sometimes. From the lecture we can clearly know that there is no plan for this change. The changes can happen any time and we must face it once it happens.

- **Changeability** :
Customers request for may changes to the software developers because their requirements change frequently. More than manufacturing a software product, pressure to change it is greater for the software team. For example let us consider a health care system. The software would have been completely built. After the review the customer may request multiple changes which may make our software developers to completely remodel the system. Customers actually do not know when to place the change request. It will become difficult for the software team if the changes are made during later stages. In other fields this change is not easy. Consider a building built in a downtown by XYZ. company. The customer cannot make big changes if the building is built because it will incur lot of costs. But in software systems customers ask us to change very easily. 


- **Invisibility**
When the requirement is given, it is very difficult to imagine the outcome of the software by the software developer. It is important that software developer should understand the problem. There are some UML diagrams which will help the software developer to visualize  the software. There are mainly 13 different types of diagrams used. Even though we have all these diagrams, it is still difficult for the developer to visualize the software. It is very difficult to state the problems using these diagrams but some kind of visualization is given by these diagrams. For example let us consider an software for a restaurant. First we must gather all requirements from customer and we must try to visualize the outcome of the software. Generally before coding, the software team first design all these diagrams and try to visualize the software.. It is very important because if the software developer does not understand the problem properly then the resultant software will be completely different from that of customer needs.

<h3>ANSWER 4 - WHY NO SILVER BULLET?</h3>
<p>Brook defines silver bullet as “A single technique or technology that by itself can deliver one order-of magnitude improvement to some aspect of software development” (Lecture). From the definition we can understand that silver bullet is a something that can improve the software system atleast by one order of magnitude. Even a small improvement is considered to be huge. He feels that there is no single technology that can improve the productivity of the software system. According to him there is no magical cure for the problems faced during manufacturing a software product. That is why he says that there is no silver bullet. </p>


